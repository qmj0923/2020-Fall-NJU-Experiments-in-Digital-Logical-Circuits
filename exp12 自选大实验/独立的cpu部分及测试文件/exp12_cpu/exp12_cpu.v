
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================
`include "macro.v"

module exp12_cpu(

	//////////// CLOCK //////////
	//input 		          		CLOCK2_50,
	//input 		          		CLOCK3_50,
	//input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	//output		     [9:0]		LEDR

	//////////// Seg7 //////////
	//output		     [6:0]		HEX0,
	//output		     [6:0]		HEX1,
	//output		     [6:0]		HEX2,
	//output		     [6:0]		HEX3,
	//output		     [6:0]		HEX4,
	//output		     [6:0]		HEX5
   
   output reg en_init, cpu_en,
   
   output wire [`INST_RAM_WIDTH-1:0] curr_PC,
   
   output wire inst_re, mem_re, mem_we, 
   output wire cpu_finished, inst_finished, 
   output wire mem_r_finished, mem_w_finished, 
   
   
   output wire [`MEM_RAM_WIDTH-1:0] mem_addr,
   output wire [31:0] inst_data, rt_data,
   output wire [31:0] exec_res, mem_data
   
   
   // output wire reg_re1, reg_re2, reg_we, 
   // output wire reg_r_finished, reg_w_finished,
   // output wire [4:0] rs_addr, rt_addr, reg_w_addr,
   // output wire [31:0] rs_data, 
   // output [2:0] state
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

wire clk, clrn;
reg tst_begin;
reg [3:0] set_cnt;
parameter set_time = 10;

//=======================================================
//  Structural coding
//=======================================================

inst_ram inst1(.clk(clk), .clrn(clrn), 
   .re(inst_re), .we(0),
   .read_addr(curr_PC), .read_data(inst_data), 
   .read_finished(inst_finished));
   
mem_ram mem1(.clk(clk), .clrn(clrn), 
   .re(mem_re), .we(mem_we),
   .read_addr(mem_addr), .read_data(mem_data),
   .write_addr(mem_addr), .write_data(rt_data),
   .read_finished(mem_r_finished), 
   .write_finished(mem_w_finished));

cpu cpu1(.clk(clk), .clrn(1), .en(cpu_en), 
   .curr_PC(curr_PC), .PC_end(92), 
   .inst_re(inst_re), .mem_re(mem_re), .mem_we(mem_we), 
   .cpu_finished(cpu_finished), .inst_finished(inst_finished), 
   .mem_r_finished(mem_r_finished), .mem_w_finished(mem_w_finished), 
   .inst_data(inst_data), .rt_data(rt_data), .exec_res(exec_res), 
   .mem_addr(mem_addr), .mem_data(mem_data)
   
   // for debug
   // .reg_re1(reg_re1), .reg_re2(reg_re2), .reg_we(reg_we), 
   // .reg_r_finished(reg_r_finished), .reg_w_finished(reg_w_finished), 
   // .rs_addr(rs_addr), .rt_addr(rt_addr), .reg_w_addr(reg_w_addr), 
   // .rs_data(rs_data), 
   // .state(state) 
);

assign clk = CLOCK_50;
assign clrn = KEY[0];

initial begin
   en_init = 0;
   set_cnt = 0;
   tst_begin = 0;
end

always @ (posedge clk) begin
   if (en_init == 0) begin
      en_init <= 1;
      cpu_en <= 1;
   end
   if (tst_begin && cpu_finished) begin
      cpu_en <= 0;
   end
end

always @ (posedge clk) begin
   if (set_cnt == set_time || tst_begin) begin
      tst_begin <= 1;
      set_cnt <= 0;
   end else begin
      set_cnt <= set_cnt + 1;
   end
end

endmodule
