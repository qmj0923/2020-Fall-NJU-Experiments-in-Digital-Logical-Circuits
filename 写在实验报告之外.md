# 写在实验报告之外

各实验报告中的*实验时间*已按照提交到课程网站上的日期进行修改。

涉及个人信息的相关内容已隐去



### exp00

本实验的LaTeX模板~~摘抄~~引用自GitHub：<https://github.com/NN708/SimpleLabReport>，侵删。



### exp03

实验报告中询问老师的聊天记录已重新截图



### exp06

~~三个月之后连自己也看不懂自己在证明些什么。~~



### exp08

该键盘模块其实是有很多缺陷的。最大的缺陷是按键松开后才会使按键次数加一，但老师要求的是按下键时立即加一（在老师录制的视频（未上传）中提到了此要求，但是在题目pdf中未明确指出）。相关实现思路可以参照exp11的键盘模块的实现。



### exp09

基础功能里的显示一张题目提供的图片（`my_picture.mif`）、以及拓展功能里的显示一张自定义图片`my_picture2.mif`），我都放在基础功能的那个工程里了（懒得重新写一个）。用的时候改一下调用`.mif`文件的代码即可。



### exp10

从实验10开始，我会把整个实验划分成几个部分。对于每个部分的代码，我会单独建立工程进行测试（下载运行或者模拟仿真）。个人觉得这样做对debug大有裨益。这些工程的核心代码放在一个标有`（某某部分）`的文件夹中，已经上传到相应实验的目录下。用Quartus运行时记得删去文件夹名称里的中文。



### exp11

此次实验的程序的缺陷是键盘的按键灵敏度的问题。我设计的键盘模块接口是把当前按键的ASCII码即时输出的，所以在显示器模块中必须设置一个刷新屏幕的时钟，按一定的频率读取键盘输出，然后输出字符到屏幕上。否则，如果按照系统提供的50MHZ的时钟把键盘输出直接输出到显示器的话，那么只要按一下键，该字符就会瞬间充满整个屏幕了。这样一来，如果我按一定的频率读取键盘输出并打印到显示器上的话，我就要控制我按键的时间：敲一个键的时间如果长了，那就会一下输出多个字符；如果时间短了，那么显示器就读取不了我敲的字符。我设置的0.2秒左右的读取频率刚刚好能做到以次充好、以假乱真的程度，然后就蒙混过关搞定了验收环节，也懒得改了。

要改也并不困难。当长按一个键时，在刚按下时输出一个该字符，然后停顿一段时间，再连续输出这个字符（具体情况可以用笔记本电脑打开一个txt，按几次键体验一下真实的键盘是如何处理长按一个键的）。



### exp12

这个实验做得非常痛苦，有非常多的遗憾。

痛苦之处在于前后的落差感。第一个星期我写CPU部分写得非常顺利，一路无bug，很完美地实现了一个多周期的CPU模块。然后我想着其他部分都是复用前几个实验，交给队友随便写写再一起找找bug应该很快就能完事。结果接下来大半个月bug层出不穷，弄得我俩心力交瘁。最后的成品也基本上不了台面：键盘模块只允许单次按键，没有连续按键没有大小写没有左右方向键；显示器只能显示软件对应的特定输出，fib之类的计算结果都是在七段数码管上体现的；没有滚屏没有写满自动清屏，只能手动按清空按钮KEY[0]来清屏；因为用的是Verilog代码而非汇编指令进行按键回显和字符串匹配，所以FPGA的资源到最后就不够用了，只好把屏幕大小由原来的30\*70删成了15\*20。还有诸多小bug：

1. 显示屏输出本次命令的结果前会闪烁一下上一个命令的结果
2. 清屏按钮不会清空上一条命令在FPGA上的执行效果。
3. 显示器上显示的字符串可能和buf中存的不一样，也就是说，就算屏幕上显示的命令格式正确，匹配的结果也可能是unknown command。

如果能从头来过的话，我一定会选择写汇编指令来实现按键回显字符串匹配等等一系列的功能，而不是用Verilog代码来实现。这样做应该可以避免以上的所有bug。可惜开弓没有回头箭，写成这样也完全没动力重头再做了。如果要重来的话，应该只需要重新写一个外设的壳子给CPU部分套上就行。毕竟从实现一个多周期CPU的角度来看，个人感觉这个CPU内核实现得还是可以的。



另：大实验exp12的评分和排名没有在课程网站上公布，我估计多半会是我所有实验里的最低分。

